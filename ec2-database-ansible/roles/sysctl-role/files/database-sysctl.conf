
#DEVICE

# TIOCSTI can be used by a program to simulate user typing
dev.tty.legacy_tiocsti = 0

#HPET is a hardware timer.To prevent abuse (e.g., malicious or buggy apps requesting 100,000 interrupts per second and killing performance), the kernel enforces this maximum frequency.
#How many interrupts can application make in one second
dev.hpet.max-user-freq = 64

****************************************************************************************************************************
FILESYSTEM

#System-wide limit on the total number of open file descriptors (FDs) the kernel will allow
#File descriptors are used not just for files, but also for sockets, pipes, devices — basically almost every kernel resource.
fs.file-max = 9223372036854775807

#Only the owner of a FIFO or root can open it for writing before any process reads from it.
fs.protected_fifos = 1
#Restricts creating hardlinks to files the user does not own (unless they have read/write access).
fs.protected_hardlinks = 1
#Controls restrictions for opening regular files in world-writable sticky directories (like /tmp).
fs.protected_regular = 2
#Prevents following symlinks in world-writable sticky directories (e.g., /tmp) if the symlink points to a file the follower shouldn’t access
fs.protected_symlinks = 1

#Controls whether the kernel allows core dumps from processes that have changed their privileges (Contains : Passwords, keys, tokens,Application logic.)
#0 -> no dumps - most secure, 2 -> dumps are allowed but in dir where root only have access - useful for debugging
fs.suid_dumpable = 0
****************************************************************************************************************************
#KERNEL

#Disable CTRL+ALT+ commands.Disable SysRq (limits kernel-level commands)
kernel.sysrq = 0

#Core dump files include PID
kernel.core_uses_pid = 1

#Restricts non-root users to access kernel messages through dmesg
kernel.dmesg_restrict = 1

#io_uring is still young, and it has had several privilege escalation / memory corruption CVEs (e.g., CVE-2021-41073, CVE-2022-1786).
#Keep 0 → modern servers, databases, or applications requiring high-performance asynchronous I/O.
kernel.io_uring_disabled = 2

#Linux that lets you load a new kernel into memory and jump to it without going through the full BIOS/UEFI + hardware initialization cycle.
kernel.kexec_load_disabled = 1


#Hide kernel pointers (addresses in kernel memory) in /proc from un-privileged users.Set 2 to hide it even from root.
kernel.kptr_restrict = 1

#It uses Non-Maskable Interrupts (NMIs) to periodically check whether CPUs are responding.
kernel.nmi_watchdog = 1

#4 → Completely disables perf_event_open for unprivileged users.
kernel.perf_event_paranoid = 4

#ASLR randomizes the memory addresses used by processes so that exploits relying on fixed addresses (like buffer overflows) are harder.
kernel.randomize_va_space = 2

##When the creating process dies, all its shared memory segments are automatically destroyed (like POSIX shared memory behavior).
kernel.shm_rmid_forced = 1

#1 → Enabled (default on most modern kernels). The kernel uses CPU features to detect or mitigate split locks, reducing performance impact or potential security issues.
kernel.split_lock_mitigate = 1

#If a CPU is stuck in kernel code too long (e.g. infinite loop, deadlock, hardware hang):The watchdog logs a “soft lockup” warning.If configured (kernel.softlockup_panic=1), the system can panic/reboot.
kernel.watchdog = 1


#Controls how strictly the kernel enforces sysctl write permissions.Prevents accidental or malicious changes to critical kernel settings.Controls how strictly the kernel validates writes to /proc/sys entries.Writes must exactly match the expected format.
kernel.sysctl_writes_strict = 1

#Unprivileged users cannot create BPF programs (restricted).BPF programs are used for network filtering, tracing, and performance monitoring.
kernel.unprivileged_bpf_disabled = 1

#Allows creating User namespaces for unprivileged users.Security risk,keep disabled unless running rootless containers or apps that are using namespaces.
kernel.unprivileged_userns_clone = 0

#1 → restricted ptrace. A process can only trace Its child processes and Processes with CAP_SYS_PTRACE capability.
kernel.yama.ptrace_scope = 1
******************************************************************************************************************************
#VIRTUAL MEMORY(VM)

#Soft-offlining means:Mark the faulty page as offline.Avoid using it in the future.No need to reboot the system
#If disabled (0):Faulty pages may cause kernel oops/panic when accessed.
vm.enable_soft_offline = 1

#A file descriptor–based API (/dev/userfaultfd) that lets a userspace process handle page faults on behalf of another process.
vm.unprivileged_userfaultfd = 0

#How often in seconds are memory statistics refreshed.(/proc/vmstat)
vm.stat_interval = 1

#0 -> The kernel runs the OOM killer heuristic.The process with the highest score is killed, not necessarily the one that requested the memory.This helps protect critical processes
vm.oom_kill_allocating_task = 0

#Linux hardening knob that controls whether memory file descriptors (memfd) can be used to create executable anonymous memory
#1 -> Systems running : Web Browsers,OpenJDK / JVM,Node.js / V8,.NET CoreeBPF JIT in the kernel
#2 -> Systems running : classic web/db hosts running nginx/httpd/PostgreSQL, no JVM/Node/Chromium/etc.
vm.memfd_noexec = 2

# Prevent users from mapping memory they shouldn't.Defines the lowest virtual address (in bytes) that a process (especially an unprivileged one) is allowed to map using mmap()
vm.mmap_min_addr = 65536

#How often to use swap.Lower number=Less used.0-100
vm.swappiness = 10


#Controls whether the memory compaction algorithm is allowed to move unevictable pages (pages that normally cannot be swapped or reclaimed).
#On container servers / general workloads Leaving it at 1 (default) is safe and usually best, because the kernel can keep memory defragmented for large allocations.
vm.compact_unevictable_allowed = 1

#Reduces RAM fragmentation.Increase number for databases.
#If set higher (e.g., 60–80):Kernel compacts memory in the background more often, keeping 2 MiB blocks ready → Postgres can grab huge pages immediately → no stall.
vm.compaction_proactiveness = 60



vm.dirty_background_bytes = 0
vm.dirty_bytes = 0
#When dirty memory exceeds this, the kernel’s background flusher (pdflush/kworker) starts writing pages back to disk.
vm.dirty_background_ratio = 10
#When dirty memory exceeds this, tasks generating dirty pages will block and help flush before proceeding.
vm.dirty_ratio = 20

#Keep it around 20-30 secs.How long can data stay in RAM before its considered old and needs to be writen to storage
vm.dirty_expire_centisecs = 3000


#Lower it to 200-300 for Database server.
#Checks whats the largest block size possible.If its smaller then 50% of available RAM Kernel compats memory to create larger blocks
vm.extfrag_threshold = 500

#Database related.Optimizing vmemmap can reduce memory overhead by storing metadata more efficiently for huge pages.
vm.hugetlb_optimize_vmemmap = 1

#Specifies the maximum number of memory map areas (VMAs) a single process can have.
#Your value 1048576 → allows up to 1 million VMAs per process, which is suitable for large database or container workloads.
vm.max_map_count = 1048576


#how Linux reacts when hardware memory errors are detected
#Databases -> 1 - early process kill avoid corruption of persistent data.
vm.memory_failure_early_kill = 1
#Should system panic and reboot (0) if error accures or isolate bad page and kill process(1).
vm.memory_failure_recovery = 1


#Reserved memory for HugePage's.2MiB * 100
vm.nr_hugepages = 100





******************************************************************************************************************************
#NET

#Compile BPF programs into native instrustions.(Faster)
net.core.bpf_jit_enable = 1

#2 – harden JIT for all users (recommended by many security baselines, e.g., RHEL/Alma STIGs)
net.core.bpf_jit_harden = 2

#A queueing discipline decides how packets are queued and scheduled for transmission on an interface.
net.core.default_qdisc = fq
tcp_congestion_control = bbr

##How many packets from same stream are stacked together before passing them.
#8 -> Balanced — good throughput with minimal added latency.Works well for most general-purpose servers.
net.core.gro_normal_batch = 8

#Linux introduced nexthop objects to make ECMP and multipath routing more powerful.Ensures older tooling (ip route add ... nexthop) and daemons still work.
net.ipv4.nexthop_compat_mode = 1

#IPV4 Forwarding
net.ipv4.ip_forward = 0

#Default 0. if your server has IP 192.168.1.10, it shouldn’t be receiving packets that claim to come from 192.168.1.10 — that looks like a spoofed packet or a loop.
net.ipv4.conf.all.accept_local = 0

#Disable!Allows to specify full route of packets.This controls whether new network interfaces will, by default, accept IP source-routed packets.
net.ipv4.conf.all.accept_source_route = 0

#Disable (0)  on most modern servers.Controls whether new network interfaces will, by default, accept ICMP Redirect messages.#best practice in secure environments is to disable sending redirects, unless your server is acting as a trusted router.
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.all.send_redirects = 0

#This controls whether the kernel forwards broadcast packets received on an interface to other interfaces.
net.ipv4.conf.all.bc_forwarding = 0
#This controls whether the host forwards IPv4 multicast traffic between interfaces.
net.ipv4.conf.all.mc_forwarding = 0

#Reverse Path Filtering checks whether the source address of a packet is reachable via the interface it arrived on.
#Value 1.Strict mode.
#Value 2.Recommended in cloud enviroments.The kernel only checks if the source IP is present in the routing table (reachable at all).
net.ipv4.conf.all.rp_filter = 2




#1 -> Protects against SYN floods and half-open connection abuse.
#net.ipv4.tcp_backlog_ack_defer = 1

#Allow windows scaling.The TCP receive window (RWIN) tells the sender how much data you can send me before I must ACK
net.ipv4.tcp_window_scaling = 1

#Controls whether the TCP stack automatically “corks” (delays) small writes from applications, so they can be coalesced into fewer, larger packets.
#1 -> Reduces packet overhead and improves throughput.
net.ipv4.tcp_autocorking = 1

#Sender sees congestion early and slows down before loss occurs.congestion = too much traffic injected into the network vs. what it can drain.
net.ipv4.tcp_ecn = 1

#Client includes the cookie + data in SYN.Server validates cookie and accepts data right away.Problem middlebox break it.
#Keep disabled,replaced with TLS.If client has a session ticket from a prior TLS handshake, it can send data immediately with the ClientHello.
net.ipv4.tcp_fastopen = 0

#This sets the timeout (in seconds) that a TCP socket in the FIN-WAIT-2 state will remain before being force-closed by the kernel.(Client needs to send final fin packet)
net.ipv4.tcp_fin_timeout = 15

#0 → Legacy recovery.1 (default) → Use RACK.RACK uses time (RTT measurements) to decide if a packet is lost.
net.ipv4.tcp_recovery = 1

#Enable/Disable SACK
net.ipv4.tcp_sack = 1

#Enable/Disable Timestamp
net.ipv4.tcp_timestamps = 1

#Normally, TCP relies on ICMP “Fragmentation Needed” messages to learn the correct MTU. But many networks/firewalls block ICMP, which can leave connections “stuck.”
#Enabled on “blackhole detection.” If packets fail repeatedly, TCP starts probing with smaller MSS until it works.
net.ipv4.tcp_mtu_probing = 1

#SYN flood / backlog protection.SYN cookies let the server withstand floods by avoiding allocation for half-opens.
#When backlog is full, the server does not allocate memory for the half-open connection.it encodes essential state (MSS, timestamp, etc.) into the server’s SYN-ACK sequence number.If the client responds with the final ACK, the server validates the cookie → only then allocates memory and establishes the connection.
net.ipv4.tcp_syncookies = 1

#0 -> Disable TIME_WAIT reuse of connection.1/2 Useful for proxy/load balancing servers
net.ipv4.tcp_tw_reuse = 0

#Without it, a stray RST/FIN packet (with old sequence numbers) could kill a valid connection in TIME_WAIT.
net.ipv4.tcp_rfc1337 = 1

#This controls whether a TCP socket in the request queue (half-open connections that have received SYN and sent SYN-ACK, waiting for the final ACK) can be migrated from one listening socket to another.
net.ipv4.tcp_migrate_req = 0

#This defines the range of ephemeral (a.k.a. dynamic) ports that Linux can assign for outbound connections.If you need more than ~28k concurrent outbound connections per IP, you may exhaust ephemeral ports.
net.ipv4.ip_local_port_range = 1024 65535
#If you are using port for something specify it here so it avoids conflicts
net.ipv4.ip_local_reserved_ports = 2222 

#Upper bound for an app’s accept queue (fully established connections waiting for accept()).
net.core.somaxconn = 16384
#Size of the SYN (half-open) queue per listening socket—connections that have received SYN and you’ve sent SYN-ACK, waiting for the final ACK.
net.ipv4.tcp_max_syn_backlog = 16384
#Per-CPU queue for ingress packets that the kernel hasn’t yet processed to the stack.
net.core.netdev_max_backlog = 65536

#Max R/W memory per socket(connection) 4MiB
net.core.rmem_max = 4194304
net.core.wmem_max = 4194304

#It’s the system-wide pool of memory that all TCP sockets on the host share.
net.ipv4.tcp_mem = 49152 65536 98304

#Per Socket
net.ipv4.tcp_rmem = 4096 131072 4194304
net.ipv4.tcp_wmem = 4096 131072 4194304

#If packets are arriving faster than the app consumes them:Kernel grows the receive buffer gradually.If app drains fast or traffic slows:Kernel keeps buffer moderate; doesn’t waste memory.
net.ipv4.tcp_moderate_rcvbuf = 1

#reset cwnd after idle → safer for the Internet.
net.ipv4.tcp_slow_start_after_idle = 1

#Governs how many times TCP will retransmit data on an established connection before giving up.
net.ipv4.tcp_retries2 = 15

#how many times the server resends SYN-ACK before abandoning the half-open handshake and freeing the slot
tcp_synack_retries = 5

#if system is tight on memory and there are many TCP sockets, Linux will send probes to idle connections every 10 minutes to check if they’re still alive.
net.ipv4.tcp_probe_interval = 300

#How long before kernel closes idle connection.They define when the kernel sends probes on otherwise idle TCP connections, and when it gives up if the peer doesn’t respond.
net.ipv4.tcp_keepalive_intvl = 60 
net.ipv4.tcp_keepalive_probes = 5
net.ipv4.tcp_keepalive_time = 300

#This sets the timeout (in seconds) that a TCP socket in the FIN-WAIT-2 state will remain before being force-closed by the kernel.(Client needs to send final fin packet)
net.ipv4.tcp_fin_timeout = 15


net.ipv6.conf.{all,default}.disable_ipv6 = 1
